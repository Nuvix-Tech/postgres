-- migrate:up

-- Create schemas
create schema if not exists system authorization nuvix_admin;
create schema if not exists core authorization nuvix_admin;

-- Create system tables
CREATE TABLE IF NOT EXISTS system.schemas (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    type VARCHAR(20) NOT NULL,
    enabled BOOL DEFAULT true,
    description TEXT,
    metadata JSONB DEFAULT '{}' NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

CREATE INDEX IF NOT EXISTS schema_name_index ON system.schemas USING BTREE (name);
CREATE INDEX IF NOT EXISTS schema_id_index ON system.schemas USING BTREE (id);
CREATE INDEX IF NOT EXISTS schema_type_index ON system.schemas USING BTREE (type);
CREATE INDEX IF NOT EXISTS schema_enabled_index ON system.schemas USING BTREE (enabled);

alter user nuvix_admin SET search_path TO system, core, auth, extensions;

-- Create functions 

CREATE OR REPLACE FUNCTION system.is_managed_schema(schema_name text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = system, pg_catalog
AS $$
DECLARE
    schema_exists boolean;
BEGIN
    -- Check if the schema exists and is of type 'managed'
    SELECT EXISTS (
        SELECT 1 FROM system.schemas
        WHERE name = schema_name AND type = 'managed'
    ) INTO schema_exists;
    RETURN schema_exists;
END;
$$;

-- System helper: apply baseline API grants to a schema
CREATE OR REPLACE FUNCTION system.apply_schema_grants(target_schema text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = system, pg_catalog
AS $$
BEGIN
  -- Allow runtime roles to see objects
  EXECUTE format('GRANT USAGE ON SCHEMA %I TO anon, authenticated, postgres', target_schema);

  -- Existing objects
  EXECUTE format('GRANT SELECT ON ALL TABLES IN SCHEMA %I TO anon, authenticated', target_schema);
  EXECUTE format('GRANT INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA %I TO authenticated', target_schema);
  EXECUTE format('GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA %I TO anon, authenticated', target_schema);
  EXECUTE format('GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA %I TO anon, authenticated', target_schema);

  -- Future objects
  EXECUTE format('ALTER DEFAULT PRIVILEGES IN SCHEMA %I GRANT SELECT ON TABLES TO anon, authenticated', target_schema);
  EXECUTE format('ALTER DEFAULT PRIVILEGES IN SCHEMA %I GRANT INSERT, UPDATE, DELETE ON TABLES TO authenticated', target_schema);
  EXECUTE format('ALTER DEFAULT PRIVILEGES IN SCHEMA %I GRANT EXECUTE ON FUNCTIONS TO anon, authenticated', target_schema);
  EXECUTE format('ALTER DEFAULT PRIVILEGES IN SCHEMA %I GRANT USAGE, SELECT ON SEQUENCES TO anon, authenticated', target_schema);
END;
$$;

-- System helper: when create table on managed schema
CREATE OR REPLACE FUNCTION system.on_managed_table_create()
RETURNS event_trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = system, pg_catalog
AS $$
DECLARE
  cmd record;
  sname text;
  tname text;
  is_managed boolean;
  has_id boolean;
  is_bigint boolean;
BEGIN
  FOR cmd IN
    SELECT * FROM pg_event_trigger_ddl_commands()
    WHERE command_tag = 'CREATE TABLE' AND object_type = 'table'
  LOOP
    sname := cmd.schema_name;
    tname := split_part(cmd.object_identity, '.', 2);

    -- Skip internal/system schemas and perms tables
    CONTINUE WHEN tname LIKE '%_perms'
           OR sname LIKE 'pg_%'
           OR sname IN ('information_schema', 'system', 'extensions');

    -- Only act for managed schemas
    SELECT system.is_managed_schema(sname) INTO is_managed;

    IF NOT is_managed THEN
      CONTINUE;
    END IF;

    -- Check for _id presence and type
    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = sname AND table_name = tname AND column_name = '_id'
    ) INTO has_id;

    IF has_id THEN
      SELECT (data_type = 'bigint')
      FROM information_schema.columns
      WHERE table_schema = sname AND table_name = tname AND column_name = '_id'
      INTO is_bigint;
    ELSE
      is_bigint := false;
    END IF;

    -- Add _id if absent or wrong type (do not drop user’s column)
    IF NOT has_id OR NOT is_bigint THEN
      PERFORM set_config('system.is_managed_table_create', 'true', true);
      EXECUTE format(
        'ALTER TABLE %I.%I ADD COLUMN IF NOT EXISTS _id BIGINT GENERATED BY DEFAULT AS IDENTITY',
        sname, tname
      );
      -- Ensure uniqueness (index allows NULLs if ever changed; identity defaults NOT NULL)
      EXECUTE format(
        'CREATE UNIQUE INDEX IF NOT EXISTS %I ON %I.%I(_id)',
        tname || '_id_key', sname, tname
      );
      PERFORM set_config('system.is_managed_table_create', 'false', true);
    END IF;

    -- Create <table>_perms if not exists (no FK to avoid migration blockers)
    EXECUTE format(
      'CREATE TABLE IF NOT EXISTS %I.%I_perms (
         id BIGSERIAL PRIMARY KEY,
         roles TEXT[] NOT NULL,
         permission TEXT NOT NULL,
         row_id BIGINT NOT NULL,
         extra JSONB DEFAULT NULL,
         created_at TIMESTAMPTZ DEFAULT NOW(),
         updated_at TIMESTAMPTZ DEFAULT NOW(),
         CONSTRAINT chk_permission CHECK (permission IN (''create'',''read'',''update'',''delete''))
       )',
      sname, tname
    );

    EXECUTE format(
      'CREATE INDEX IF NOT EXISTS %I_perms_roles_gin_idx ON %I.%I_perms USING GIN (roles)',
      tname, sname, tname
    );
    EXECUTE format(
      'CREATE INDEX IF NOT EXISTS %I_perms_perm_row_idx ON %I.%I_perms (permission, row_id)',
      tname, sname, tname
    );

    EXECUTE format(
      'COMMENT ON TABLE %I.%I_perms IS %L',
      sname, tname, 'Permission system for ' || sname || '.' || tname
    );
  END LOOP;
END;
$$;

-- System helper: when drop table on managed schema
-- Cleans up permissions table and system.tables entry if exists
-- Note: this does not drop the table itself, only cleans up related metadata
--       the table will be dropped by the default PostgreSQL behavior
--       this function is only for cleaning up permissions and system metadata
CREATE OR REPLACE FUNCTION system.on_managed_table_drop()
RETURNS event_trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = system, pg_catalog
AS $$
DECLARE
    obj record;
    schema_name text;
    table_name text;
    is_managed boolean;
BEGIN
    -- Handle dropped tables
    FOR obj IN
        SELECT *
        FROM pg_event_trigger_dropped_objects()
        WHERE object_type = 'table'
          AND NOT is_temporary
    LOOP
        schema_name := obj.schema_name;
        table_name  := obj.object_name;

        -- Skip system/internal schemas & perms tables
        CONTINUE WHEN table_name LIKE '%_perms';
        CONTINUE WHEN schema_name IN ('system', 'pg_catalog', 'information_schema');

        -- Check if schema is managed
        SELECT system.is_managed_schema(schema_name) INTO is_managed;

        IF NOT is_managed THEN
            CONTINUE;
        END IF;

        -- Drop <table>_perms if it exists
        IF EXISTS (
            SELECT 1
            FROM pg_class c
            JOIN pg_namespace n ON n.oid = c.relnamespace
            WHERE n.nspname = schema_name
              AND c.relname = table_name || '_perms'
        ) THEN
            BEGIN
                EXECUTE format(
                    'DROP TABLE IF EXISTS %I.%I_perms',
                    schema_name, table_name
                );
            EXCEPTION WHEN OTHERS THEN
                RAISE WARNING
                    'Failed to clean up permissions table for %.%: %',
                    schema_name, table_name, SQLERRM;
            END;
        END IF;
    END LOOP;
END;
$$;

-- System helper: block dropping orphaned permissions tables
-- This function prevents dropping of permissions tables (ending with _perms)
-- if the base table still exists, unless the developer has explicitly allowed it
CREATE OR REPLACE FUNCTION system.block_orphan_perms_table_drop()
RETURNS event_trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = system, pg_catalog
AS $$
DECLARE
    obj record;
    schema_name text;
    table_name text;
    base_table text;
    is_managed boolean;
    base_table_exists boolean;
    allow_override boolean;
BEGIN
    -- Check if override flag is enabled (developer escape hatch)
    SELECT current_setting('system.allow_orphan_perms_drop', true) = 'on'
    INTO allow_override;

    FOR obj IN
        SELECT *
        FROM pg_event_trigger_dropped_objects()
    LOOP
        -- Only proceed if it’s a table ending with _perms
        IF obj.object_type = 'table'
           AND obj.schema_name IS NOT NULL
           AND obj.object_name LIKE '%_perms' THEN

            schema_name := obj.schema_name;
            table_name  := obj.object_name;
            base_table  := regexp_replace(table_name, '_perms$', '');

            -- Check if schema is managed
            SELECT system.is_managed_schema(schema_name) INTO is_managed;

            IF NOT is_managed THEN
                CONTINUE; -- only enforce in managed schemas
            END IF;

            -- Check if base table still exists
            SELECT EXISTS (
                SELECT 1
                FROM pg_class c
                JOIN pg_namespace n ON n.oid = c.relnamespace
                WHERE n.nspname = schema_name
                  AND c.relname = base_table
            ) INTO base_table_exists;

            -- Block if base table exists, unless override enabled
            IF base_table_exists AND NOT allow_override THEN
                RAISE EXCEPTION
                    'Cannot drop %.%: base table % still exists. Drop the base table first.', --(or set system.allow_orphan_perms_drop = on)
                    schema_name, table_name, base_table;
            END IF;
        END IF;
    END LOOP;
END;
$$;

-- System helper: block creation of invalid permissions tables
-- This function prevents creation of permissions tables (ending with _perms)
-- if the base table does not exist in a managed schema, unless the developer has explicitly allowed
CREATE OR REPLACE FUNCTION system.block_invalid_perms_table_creation()
RETURNS event_trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = system, pg_catalog
AS $$
DECLARE
    cmd record;
    schema_name text;
    table_name text;
    base_table text;
    is_managed boolean;
    base_table_exists boolean;
    allow_override boolean;
BEGIN
    -- Optional override flag for migrations / dev work
    SELECT current_setting('system.allow_invalid_perms_creation', true) = 'on'
    INTO allow_override;

    FOR cmd IN
        SELECT *
        FROM pg_event_trigger_ddl_commands()
        WHERE command_tag = 'CREATE TABLE' AND object_type = 'table'
    LOOP
        schema_name := cmd.schema_name;
        table_name  := split_part(cmd.object_identity, '.', 2);

        -- Only apply check to *_perms tables
        IF table_name LIKE '%_perms' THEN
            -- Check if schema is managed
            SELECT system.is_managed_schema(schema_name) INTO is_managed;

            IF NOT is_managed THEN
                CONTINUE;
            END IF;

            base_table := regexp_replace(table_name, '_perms$', '');

            -- Check if base table exists
            SELECT EXISTS (
                SELECT 1
                FROM pg_class c
                JOIN pg_namespace n ON n.oid = c.relnamespace
                WHERE n.nspname = schema_name
                  AND c.relname = base_table
            ) INTO base_table_exists;

            -- Block if base table missing (unless override is enabled)
            IF NOT base_table_exists AND NOT allow_override THEN
                RAISE EXCEPTION
                    'Cannot create %.%: base table % does not exist in managed schema.', -- (Override with system.allow_invalid_perms_creation = on)
                    schema_name, table_name, base_table;
            END IF;
        END IF;
    END LOOP;
END;
$$;

-- System helper: block altering permissions tables when base table exists
-- This function prevents altering, renaming or dropping permissions tables
CREATE OR REPLACE FUNCTION system.block_alter_perms()
RETURNS event_trigger
LANGUAGE plpgsql
AS $$
DECLARE
    obj record;
    base_table_name text;
    schema_name text;
    is_managed boolean;
    base_exists boolean;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands() LOOP
        -- Only intercept ALTER / RENAME / DROP TABLE
        IF obj.command_tag IN ('ALTER TABLE', 'ALTER TABLE ONLY', 'DROP TABLE', 'RENAME TABLE') THEN
            schema_name := obj.schema_name;
            
            -- Check if it's a _perms table in managed schema
            IF obj.object_identity ~ '_perms$' THEN
                -- Derive base table name (strip _perms suffix)
                base_table_name := regexp_replace(obj.object_identity, '_perms$', '');

                SELECT system.is_managed_schema(schema_name) INTO is_managed;

                IF is_managed THEN
                    -- Check if base table exists
                    SELECT EXISTS (
                        SELECT 1
                        FROM information_schema.tables
                        WHERE table_schema = schema_name
                          AND table_name = base_table_name
                    ) INTO base_exists;

                    -- If base exists → block
                    IF base_exists THEN
                        RAISE EXCEPTION 'Cannot alter/rename/drop %.% when base table exists',
                            schema_name, obj.object_identity;
                    END IF;
                END IF;
            END IF;
        END IF;
    END LOOP;
END;
$$;

-- System helper: block dropping of _id columns and sequences in managed schemas
-- This function prevents dropping of _id columns and _id_seq sequences
CREATE OR REPLACE FUNCTION system.block_managed_id_drop()
RETURNS event_trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    obj record;
    schema_name text;
    table_name text;
    column_name text;
    is_managed boolean;
    is_system_add_id boolean;
BEGIN
    -- Check if we are in the middle of a system-managed table creation
    is_system_add_id := COALESCE(
        current_setting('system.is_managed_table_create', true) = 'true',
        false
    );

    IF is_system_add_id THEN
        RAISE NOTICE 'System-managed operation detected, skipping _id protection checks';
        RETURN;
    END IF;

    ----------------------------------------------------------------
    -- 1. Block dropping of "_id" column in managed schemas
    ----------------------------------------------------------------
    FOR obj IN
        SELECT * FROM pg_event_trigger_dropped_objects()
        WHERE object_type = 'table column'
    LOOP
        schema_name := obj.schema_name;
        table_name := split_part(obj.object_identity, '.', 2);
        column_name := regexp_replace(obj.object_identity, '.*\.', '');

        -- Check if schema is managed
        select system.is_managed_schema(schema_name) INTO is_managed;

        IF is_managed AND column_name = '_id' THEN
            RAISE EXCEPTION
                'Cannot drop column "_id" from %I.%I: managed schemas protect identifier columns',
                schema_name, table_name;
        END IF;
    END LOOP;

    ----------------------------------------------------------------
    -- 2. Block dropping of "_id_seq" sequences in managed schemas
    ----------------------------------------------------------------
    FOR obj IN
        SELECT * FROM pg_event_trigger_dropped_objects()
        WHERE object_type = 'sequence'
          AND obj.object_name ~ '_id_seq$'
    LOOP
        schema_name := obj.schema_name;
        table_name := regexp_replace(obj.object_name, '_id_seq$', '');

        EXECUTE format(
            'SELECT EXISTS (
                SELECT 1 FROM system.schemas 
                WHERE name = %L AND type = ''managed''
            )',
            schema_name
        ) INTO is_managed;

        IF is_managed THEN
            RAISE EXCEPTION
                'Cannot drop sequence %I.%I: managed schemas protect _id sequences',
                schema_name, obj.object_name;
        END IF;
    END LOOP;
END;
$$;

-- System helper: controlled rename of permissions tables
-- This function allows renaming of permissions tables (_perms) only if the base table exists
CREATE OR REPLACE FUNCTION system.rename_perms_table(
    p_schema_name TEXT,
    p_original_table_name TEXT,
    p_new_table_name TEXT
) RETURNS VOID AS $$
DECLARE
    perms_table_exists boolean;
    base_table_exists boolean;
BEGIN
    -- Check if base table exists in a managed schema
    EXECUTE format(
        'SELECT EXISTS (
            SELECT 1
            FROM system.schemas s
            JOIN system.tables t ON t.schema_id = s.id
            WHERE s.name = %L
              AND s.type = ''managed''
              AND t.name = %L
        )',
        p_schema_name, p_original_table_name
    ) INTO base_table_exists;

    IF NOT base_table_exists THEN
        RAISE EXCEPTION 'Base table %I.%I does not exist or schema is not managed',
            p_schema_name, p_original_table_name;
    END IF;

    -- Check if perms table exists
    EXECUTE format(
        'SELECT EXISTS (
            SELECT 1
            FROM pg_class c
            JOIN pg_namespace n ON c.relnamespace = n.oid
            WHERE n.nspname = %L
              AND c.relname = %L
              AND c.relkind = ''r''
        )',
        p_schema_name, p_original_table_name || '_perms'
    ) INTO perms_table_exists;

    IF perms_table_exists THEN
        BEGIN
            -- Allow controlled perms rename
            PERFORM set_config('system.allow_perms_rename', 'true', true);

            -- Perform the rename
            EXECUTE format(
                'ALTER TABLE %I.%I RENAME TO %I',
                p_schema_name,
                p_original_table_name || '_perms',
                p_new_table_name || '_perms'
            );
        EXCEPTION WHEN OTHERS THEN
            -- Always clear flag, even on error
            PERFORM set_config('system.allow_perms_rename', 'false', true);
            RAISE;
        END;

        -- Reset bypass flag after success
        PERFORM set_config('system.allow_perms_rename', 'false', true);
    ELSE
        RAISE NOTICE 'No _perms table found for %I.%I, skipping rename',
            p_schema_name, p_original_table_name;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;



-- Attach event triggers for managed-schema protections (id/perm table lifecycle)
DROP EVENT TRIGGER IF EXISTS nuvix_on_managed_table_create;
CREATE EVENT TRIGGER nuvix_on_managed_table_create
  ON ddl_command_end
  WHEN TAG IN ('CREATE TABLE')
  EXECUTE PROCEDURE system.on_managed_table_create();

DROP EVENT TRIGGER IF EXISTS nuvix_block_invalid_perms_creation;
CREATE EVENT TRIGGER nuvix_block_invalid_perms_creation
    ON ddl_command_start
    WHEN TAG IN ('CREATE TABLE')
    EXECUTE PROCEDURE system.block_invalid_perms_table_creation();

DROP EVENT TRIGGER IF EXISTS nuvix_block_alter_perms;
CREATE EVENT TRIGGER nuvix_block_alter_perms
    ON ddl_command_start
    WHEN TAG IN ('ALTER TABLE','ALTER TABLE ONLY','DROP TABLE','RENAME TABLE')
    EXECUTE PROCEDURE system.block_alter_perms();

DROP EVENT TRIGGER IF EXISTS nuvix_block_orphan_perms_drop;
CREATE EVENT TRIGGER nuvix_block_orphan_perms_drop
    ON sql_drop
    EXECUTE PROCEDURE system.block_orphan_perms_table_drop();

DROP EVENT TRIGGER IF EXISTS nuvix_on_managed_table_drop;
CREATE EVENT TRIGGER nuvix_on_managed_table_drop
    ON sql_drop
    EXECUTE PROCEDURE system.on_managed_table_drop();

DROP EVENT TRIGGER IF EXISTS nuvix_block_managed_id_drop;
CREATE EVENT TRIGGER nuvix_block_managed_id_drop
    ON sql_drop
    EXECUTE PROCEDURE system.block_managed_id_drop();

DROP EVENT TRIGGER IF EXISTS nuvix_rename_perms_table; 
CREATE EVENT TRIGGER nuvix_rename_perms_table
    ON ddl_command_start
    WHEN TAG IN ('ALTER TABLE', 'RENAME TABLE')
    EXECUTE PROCEDURE system.rename_perms_table();
